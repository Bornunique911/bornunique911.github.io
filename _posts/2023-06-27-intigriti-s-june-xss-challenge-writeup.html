---
layout: post
title: "Intigriti’s June XSS challenge: Writeup"
date: 2023-06-27
categories: [Web Exploitation,Bug Bounty]
tags: [xss-challenge, bug-bounty, prototype-pollution, xss-attack, intigriti]
---
<figure><img alt="https://challenge-0623.intigriti.io/" src="https://cdn-images-1.medium.com/max/860/1*jkqmV10-CRpLBifuHG7L2A.png" /><figcaption>Intigriti’s June XSS Challenge By <a href="https://twitter.com/0xGodson_">@0xGodson_</a> (<a href="https://challenge-0623.intigriti.io/">https://challenge-0623.intigriti.io/</a>)</figcaption></figure><p>Hello everyone, I hope you all are doing great things and learning new things everyday just like me. So I am here with my new and freshly written writeup blog on Intigriti’s June XSS Challenge published by <a href="https://twitter.com/0xGodson_">@0xGodson_</a> on Intigriti platform.</p><p>— — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><h4><strong><em>Introduction :</em></strong></h4><p>The following is my write-up for the <a href="https://twitter.com/intigriti/status/1670737265973182466">June 2023 Intigriti XSS challenge</a>.</p><p>Challenge URL : <a href="https://challenge-0623.intigriti.io/challenge/index.html">https://challenge-0623.intigriti.io/challenge/index.html</a></p><p><strong><em>Timeline of the challenge :</em></strong></p><p>Find a way to execute arbitrary javascript on the challenge page and win Intigriti swag.</p><p><strong><em>Rules :</em></strong></p><ul><li>This challenge runs from the 19th of June until the 26th of June, 11:59 PM CET.</li><li>Out of all correct submissions, we will draw <strong>six</strong> winners on Tuesday, the 27th of June:<br>* Three randomly drawn correct submissions<br>* Three best write-ups</li><li>Every winner gets a €50 swag voucher for our <a href="https://swag.intigriti.com/">swag shop</a> .</li><li>The winners will be announced on our <a href="https://twitter.com/intigriti">Twitter profile</a>.</li><li>For every 100 likes, we’ll add a tip to <a href="https://go.intigriti.com/challenge-tips">announcement tweet</a>.</li><li>Join our <a href="https://go.intigriti.com/discord">Discord</a> to discuss the challenge!</li></ul><p><strong><em>The solution…</em></strong></p><ul><li>Should work on the latest version of Chrome.</li><li>Should execute alert(document.cookie).</li><li>Should leverage a cross site scripting vulnerability on this domain.</li><li>Shouldn’t be self-XSS or related to MiTM attacks.</li><li>Should be reported at <a href="https://go.intigriti.com/submit-solution">go.intigriti.com/submit-solution</a>.</li><li>Should require no user interaction.</li></ul><p>— — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><p><strong><em>Let’s Do some Enumeration First…</em></strong></p><p>The challenge takes place on a single web page hosted at <a href="https://challenge-0623.intigriti.io/challenge/index.html">https://challenge-0623.intigriti.io/challenge/index.html</a>. This web page presents a dynamic interface that will test our skills in identifying and exploiting web application vulnerabilities.</p><p>The distinctive feature of the page is a facility to welcome you with your name as a popup message.</p><p>Okay, it appears that the page is straightforward, allowing users to enter their name as input in a text field.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_Hi4QvSpZmtT2QRJaDtrqQ.png" /><figcaption>Before clicking submit button and entering test in an input field</figcaption></figure><p>Upon submission, a popup message greets the user with their inputted name.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Q8SIY5S2eq9jD2OvB6kWjw.png" /><figcaption>After clicking submit button inputted name test pops up</figcaption></figure><p>Before proceeding with the enumeration, let’s examine the conditions that must be met for the solution to be accepted as a submission:</p><ol><li><strong><em>Compatibility</em></strong> : The solution should work on the latest version of Chrome based on your distribution.</li><li><strong><em>Execution of Code</em></strong> : The solution should successfully execute the code “alert(document.cookie)”.</li><li><strong><em>Cross-Site Scripting Vulnerability</em></strong>: The solution should leverage a <strong><em>cross-site scripting vulnerability</em></strong> specific to the domain in question.</li><li><strong><em>Avoidance of Self-XSS and MiTM Attacks</em></strong>: The solution should not be susceptible to <strong><em>self-XSS</em></strong> or related to <strong><em>Man-in-the-Middle</em></strong> (<strong><em>MiTM</em></strong>) attacks.</li></ol><p>Okay, before we proceed with the last two conditions, let’s take a moment to address a common question that may arise among our beginner hacker friends: What is <strong><em>self-XSS</em></strong> ? So, let’s derive the definition of <strong><em>self-XSS</em></strong>.</p><blockquote><strong><em>What is self-XSS ?</em></strong></blockquote><blockquote>The term “<strong><em>self-XSS</em></strong>” refers to a type of <strong><em>XSS</em></strong> (<strong><em>Cross-Site Scripting</em></strong>) vulnerability that occurs when an attacker tricks a user into executing malicious code within their own browser. In <strong><em>self-XSS</em></strong> attacks, the user is typically convinced to manually enter or paste malicious code into their browser’s developer console or address bar.</blockquote><p>5. <strong><em>Reporting </em></strong>: The solution should be reported at <a href="https://go.intigriti.com/submit-solution">go.intigriti.com/submit-solution</a>.</p><p>6. <strong><em>User Interaction</em></strong> : The solution should not require any user interaction to function correctly.</p><p>By ensuring that our solution should satisfies these conditions, we can proceed further confidently with the enumeration process.</p><p>Okay, before we proceed further, let’s take a moment again to address a common question that may arise among our beginner hacker friends: What is cross-site scripting (XSS)? So, let’s cease for a moment and derive the definition of cross-site scripting to gain a deeper understanding.</p><blockquote><strong><em>What is Cross-Site Scripting?</em></strong></blockquote><blockquote><strong>Cross-Site Scripting</strong> also known as <strong>XSS</strong>, is a web application vulnerability, that allows an attacker to inject malicious code into a web page that is viewed by other users. The injected code can execute in the user’s web browser and can potentially steal user’s information.</blockquote><p>Now that we have defined <strong><em>cross-site scripting</em></strong>, another question that may arise is the meaning of the term “<strong><em>vulnerability</em></strong>.” Let’s take a moment to define what a <strong><em>vulnerability</em></strong> is as well.</p><blockquote><strong><em>What is a vulnerability?</em></strong></blockquote><blockquote>A <strong>vulnerability</strong> is a weakness in a system,network or application.</blockquote><p>During our previous examination of the web application domain, we observed that when users enter their name in a text field, it is reflected back to them in the form of a greeting popup. This reflection occurs without undergoing proper sanitization or validation. Consequently, we can conclude that the input field in the web application domain is vulnerable to <strong><em>Reflected XSS</em></strong>.</p><p>Halted. So, let’s take a moment to understand the meaning of the term “<strong><em>Reflected XSS</em></strong>.”</p><blockquote><strong><em>What is Reflected XSS?</em></strong></blockquote><blockquote>It is an simplest variety of XSS. <strong><em>Reflected XSS</em></strong> (Cross-Site Scripting) is a type of web vulnerability that occurs when user-supplied data is echoed back to the user without proper sanitization or validation, allowing malicious code to be executed within the victim’s browser.</blockquote><p>Now, that we have confirmed that input field in the web application domain is vulnerable to <strong><em>Reflected XSS</em></strong>, we can utilise malicious JavaScript code such as the following :</p><pre>&lt;script&gt;alert(1)&lt;/script&gt;</pre><p>Let’s utilise that payload by entering it into the name input field. Let’s see what we get.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*fOB2Gz31M7orhYSjkBlm4A.png" /><figcaption>Before clicking submit button and inputting the payload</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_PSFKP_ZgnzKcSCk0baPKA.png" /><figcaption>After submission the output we get</figcaption></figure><p>As we can observe from the above screenshot, the alert(1) payload was executed, but it did not provide any response in the form of a popup message displaying 1. Instead, it displayed a blank response with a popup. Based on this observation, we can conclude that <strong><em>input sanitization</em></strong> has been handled properly. However, this raises a question regarding <strong><em>input validation</em></strong>.</p><p>Pause. Before we proceed, let’s pause for a moment to easily grasp the concepts of <strong><em>input sanitization</em></strong> and <strong><em>input validation</em></strong>, as well as understand the difference between the two.</p><blockquote><strong><em>What is Input sanitization?</em></strong></blockquote><blockquote><strong>Input sanitization</strong> refers to the process of filtering and modifying user input to remove or neutralize any potentially malicious or unintended content that could be executed as code within a web application.</blockquote><blockquote><strong><em>What is Input Validation?</em></strong></blockquote><blockquote><strong>Input validation</strong> focuses on verifying the correctness and integrity of user input. It involves checking the format, length, and type of input data to ensure it meets the expected criteria. <strong>Validation</strong> can be done through regular expressions, predefined rules, or custom logic.</blockquote><blockquote><strong><em>Difference between Input Sanitization and Input Validation :</em></strong></blockquote><blockquote>The difference between <strong>input sanitization</strong> and <strong>input validation</strong> lies in their goals and approaches:</blockquote><blockquote><strong>Input sanitization</strong> primarily aims to neutralize or eliminate any potential malicious code that can be embedded in user input. It focuses on cleaning the input to prevent code injection attacks like <strong>XSS</strong>.</blockquote><blockquote><strong>Input validation</strong>, on the other hand, focuses on checking the integrity and correctness of the input. It ensures that the input meets specific criteria or conforms to expected patterns, regardless of whether it contains malicious code or not.</blockquote><blockquote>In summary, <strong>input sanitization</strong> is concerned with removing or neutralizing malicious code, while <strong>input validation</strong> focuses on verifying the correctness and conformity of the input data. Both measures are crucial for securing web applications against XSS attacks.</blockquote><p>Now that we understand the terms <strong><em>input sanitization</em></strong> and <strong><em>input validation</em></strong> and their differences, let’s proceed to enumerate the <strong><em>input validation</em></strong> mechanisms by viewing the page source of the web application domain. To open the page source of the web application domain, you can press <strong><em>CTRL+U</em></strong> on your keyboard or right-click on the page and select the <strong><em>View Page Source</em></strong> option from the available menu.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dIzw17jG6WfhH9hWODOLgQ.png" /><figcaption>Source code of a web application domain</figcaption></figure><p>So, as we can observe from the above screenshot, we have three files to look for, which are present under the <strong><em>&lt;script&gt;</em></strong> tag in the source code of the web application domain. The three files available to view are located on the <strong><em>/static/</em></strong> endpoint of the web application domain.</p><p>Therefore, as we can observe from the above screenshot, we have one <strong><em>CSS</em></strong> file named <strong><em>tailwind.min.css</em></strong> and the other two files are <strong><em>JavaScript</em></strong> files named <strong><em>jquery-2.2.4.js</em></strong> and <strong><em>jquery-deparam.js</em></strong> respectively.</p><p>From my experience in solving web challenges during CTF, I should mention that <strong><em>CSS</em></strong> files handle how HTML elements are displayed on the screen, paper, or other media. On the other hand, <strong><em>JavaScript</em></strong> files contain JavaScript code for execution on web pages.</p><p>Considering this, I believe the <strong><em>JavaScript</em></strong> files could be a point of interest to look at first, rather than the <strong><em>CSS</em></strong> file, as we are trying to find the input validation code mechanism.</p><p>So, let’s look at the <strong><em>JavaScript</em></strong> files one by one. First, let’s examine the <strong><em>jquery-2.2.4.js</em></strong> file. Let’s see what it contains.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*T5D-CJFLODwPwI5xvx2pzA.png" /><figcaption>Source code of file jquery-2.2.4.js</figcaption></figure><p>Based on the provided screenshot, we can conclude that the web application domain is using the <strong><em>jQuery JavaScript Library v2.2.4</em></strong>. Now, we know the exact version of <strong><em>jQuery</em></strong>, which is the most commonly used library in the <strong><em>JavaScript language</em></strong>. Let’s proceed with our second JavaScript file named <strong><em>jquery-deparam.js</em></strong> and examine its contents. Let’s see what it contains.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*1SxHky66wkPVUjVNWiQnUw.png" /><figcaption>Source code of jquery-deparam.js</figcaption></figure><p>Based on the provided screenshot, we can conclude that the web application domain uses the <strong><em>jquery-deparam</em></strong> method. This method serves as an inverse of <strong><em>jQuery’s</em></strong> <strong><em>$.param</em></strong> method and is used to convert a query string into a JavaScript object, which is included in the <strong><em>jquery-deparam.js</em></strong> file.</p><p>So, from the two JavaScript files, we have learned about the <strong><em>version of </em></strong><strong><em>jQuery</em></strong> from <strong><em>jquery-2.2.4.js</em></strong> and also the <strong><em>method of jQuery</em></strong> it utilises from <strong><em>jquery-deparam.js</em></strong>.</p><p>So, let’s research the <strong><em>jquery-deparam</em></strong> method of jQuery on Google, as Google is our trusted ally in hacking.&quot;</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lc5qh6gtcZgSpdEHIRt3ug.png" /><figcaption>Googling jquery deparam method</figcaption></figure><p>From the above screenshot, we have found that there is a prototype pollution in the <strong><em>jquery-deparam</em></strong> method, which seems to be interesting to look into. Let’s go deeper into it and see what it’s all about.</p><p>Upon landing on <a href="https://security.snyk.io/vuln/SNYK-JS-JQUERYDEPARAM-1255651">Snyk’s</a> page, we can learn more about the Prototype Pollution vulnerability that affects JavaScript method <strong><em>jquery-deparam</em></strong>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*6n02jNegjeshfqzWP6Wc1A.png" /><figcaption>Prototype Pollution affecting JavaScript</figcaption></figure><p>Hold on. Let’s take a moment to understand the meaning of the term “<strong><em>Prototype Pollution</em></strong>”.</p><blockquote>What is <strong>Prototype Pollution</strong>?</blockquote><blockquote><strong>Prototype Pollution</strong> is a vulnerability or a type of security issue that occurs in some programming languages, especially those that support object-oriented programming and prototype-based inheritance. It occurs when a software application or system allows an attacker to modify the behavior of existing objects or classes by injecting malicious values into their prototypes.</blockquote><blockquote>In simpler terms, <strong>Prototype Pollution</strong> refers to the ability to manipulate or pollute the prototype of an object, leading to unintended consequences in the application’s behavior. <strong>Attackers</strong> can exploit this vulnerability <strong>to modify or add properties and methods to objects</strong> that may be used throughout the application. This can result in various security risks, such as <strong>remote code execution</strong>, <strong>privilege escalation</strong>, or <strong>denial-of-service attacks</strong>.</blockquote><blockquote>Developers need to be <strong>aware of this vulnerability</strong> and take <strong>preventive measures</strong>, such as <strong>proper input validation</strong>, <strong>sanitization</strong>, and <strong>implementing secure coding practices</strong>, to mitigate the <strong>risk of Prototype Pollution</strong> in their applications.</blockquote><p>Now that we understand the concept of Prototype Pollution, let’s move ahead and explore how we can exploit it. Furthermore, if you want to learn more about how this vulnerability works on the JavaScript method jquery-deparam, you can read more about it here.</p><ul><li><a href="https://security.snyk.io/vuln/SNYK-JS-JQUERYDEPARAM-1255651">Snyk Vulnerability Database | Snyk</a></li><li><a href="https://www.cve.org/CVERecord?id=CVE-2021-20087">cve-website</a></li></ul><p>Now, based on the <strong><em>initial reconnaissance</em></strong>, we know that the web application domain is vulnerable to <strong><em>Reflected XSS</em></strong>. Therefore, there is a possibility of a <strong><em>Reflected XSS vulnerability via the Prototype Pollution vulnerability</em></strong> in the web application’s domain <strong><em>name input field</em></strong>. Additionally, it is important to note that there is a <strong><em>CVE</em></strong> (<strong><em>Common Vulnerability Exposure</em></strong>) assigned to the <strong><em>Prototype Pollution vulnerability</em></strong>, specifically affecting JavaScript’s <strong><em>jquery-deparam</em></strong> method (<a href="https://www.cve.org/CVERecord?id=CVE-2021-20087"><strong><em>CVE-2021–20087</em></strong></a>). Further investigation into this <strong><em>CVE</em></strong> revealed that <strong><em>an attacker</em></strong> can exploit the <strong><em>Prototype Pollution vulnerability</em></strong> in the JavaScript <strong><em>jquery-deparam</em></strong> method by injecting properties into <strong><em>Object.prototype</em></strong>.</p><p>Based on the references provided by <a href="https://security.snyk.io/vuln/SNYK-JS-JQUERYDEPARAM-1255651">Snyk</a> and <a href="https://www.cve.org/CVERecord?id=CVE-2021-20087">cve.org</a>, we can read and learn more about the vulnerable code fragment and check the Proof of Concept on the provided links :</p><ul><li><a href="https://github.com/AceMetrix/jquery-deparam/blob/81428b3939c4cbe488202b5fa823ad661d64fb49/jquery-deparam.js#L22-L117">jquery-deparam/jquery-deparam.js at 81428b3939c4cbe488202b5fa823ad661d64fb49 · AceMetrix/jquery-deparam</a></li><li><a href="https://github.com/BlackFan/client-side-prototype-pollution/blob/master/pp/jquery-deparam.md">client-side-prototype-pollution/pp/jquery-deparam.md at master · BlackFan/client-side-prototype-pollution</a></li></ul><p>By taking a look at the vulnerable code fragment, we also have a Proof of Concept mentioned below the vulnerable code fragment that we can use to exploit the Reflected XSS via Prototype Pollution vulnerability, as follows :</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mwU5raCQk2CFyHq3_d-BIw.png" /><figcaption>Proof of Concept for CVE-2021–20087</figcaption></figure><p>But when we use the aforementioned Proof of Concept, we are unable to achieve the goal of retrieving the cookie value from the <strong><em>document.cookie</em></strong> variable mentioned in the source code of the main page, which is as follows :</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WZoEVvi_8mXW4ewTP2UsnA.png" /><figcaption>Source code of main page (<a href="https://challenge-0623.intigriti.io/challenge/index.html">https://challenge-0623.intigriti.io/challenge/index.html</a>)</figcaption></figure><p>So, I first tested the existence of the <strong><em>Reflected XSS via Prototype Pollution vulnerability</em></strong> by following the research on Prototype Pollution and the mentioned <strong><em>Proof of Concept</em></strong> from the <a href="https://github.com/BlackFan/client-side-prototype-pollution/blob/master/pp/jquery-deparam.md"><strong><em>Snyk’s reference link</em></strong></a>. I determined whether it is vulnerable or not by utilising the provided information.</p><p><a href="https://blog.s1r1us.ninja/research/PP">s1r1us - Prototype Pollution</a></p><p>While reading the research, I discovered that the web application domain was vulnerable. I confirmed this by identifying the vulnerable library, which you guys can refer to here:</p><p><a href="https://blog.s1r1us.ninja/research/PP#h.qmi78tgq85e6">s1r1us - Prototype Pollution</a></p><p>And when I followed the same steps mentioned in the research blog post on the vulnerable web application domain, I obtained the expected output as described in the research blog post.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3uDsVFfQDXf3qkYhl6eJmg.png" /><figcaption><strong><em>Blocking the JS resource request</em></strong> in Chrome and <strong>setting Debugger breakpoint when the property is Object.Prototype</strong>.</figcaption></figure><p>No worries, this was quite a technical part. However, after <strong><em>setting a breakpoint</em></strong>, we have the next step to follow, which is <strong><em>finding the script gadgets</em></strong>.</p><blockquote>What are <strong><em>gadgets</em></strong> in the context of <strong><em>prototype pollution</em></strong>?</blockquote><blockquote>In the <strong>context of prototype pollution</strong>, <strong>gadgets</strong> refer to specific code snippets or components that can be manipulated or abused to exploit vulnerabilities and potentially compromise the security or integrity of an application or system. These gadgets are typically used in attacks that target the prototype chain of an object-oriented programming language.</blockquote><p>So, to find the script gadgets, I used the following reference to exploit the Reflected XSS via Prototype Pollution vulnerability. I employed a Proof of Concept of jQuery, as one of its libraries named deparam was vulnerable.</p><p><a href="https://github.com/BlackFan/client-side-prototype-pollution/blob/master/gadgets/jquery.md">client-side-prototype-pollution/gadgets/jquery.md at master · BlackFan/client-side-prototype-pollution</a></p><p>The payload I used to exploit was as follows: I checked whether it successfully retrieves the domain or not. In fact, it did, so I added <strong><em>document.cookie</em></strong> to the payload to fetch the value of the <strong><em>document.cookie</em></strong> variable. Consequently, it turned out to be a successful payload.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pvZqYhHEjb_FL3oXNJ42MA.png" /><figcaption>Payload used for retrieving document.domain and document.cookie variable</figcaption></figure><p>The following payload retrieves the web application’s domain.</p><p><strong><em>?__proto__[preventDefault]=x&amp;__proto__[handleObj]=x&amp;__proto__[delegateTarget]=&lt;img/src/onerror%3dalert(document.domain)&gt;</em></strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lGeOlFb94oLOwpgEQYfh8A.png" /><figcaption>Screenshot for the value of document.domain</figcaption></figure><p>The following payload retrieves the web application’s cookie.</p><p><strong><em>?__proto__[preventDefault]=x&amp;__proto__[handleObj]=x&amp;__proto__[delegateTarget]=&lt;img/src/onerror%3dalert(document.cookie)&gt;</em></strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*yY6V0R7LdstLA2hLRZYtRA.png" /><figcaption>Screenshot for the value of document.cookie</figcaption></figure><p>Hence, we successfully completed the XSS challenge given by <a href="https://twitter.com/0xGodson_">@0xGodson_</a></p><p>Also I want to give a huge shout out to the awesome people who has done a good job in researching, making a Proof of Concepts and security awareness about vulnerabilities among all hackers :</p><p><a href="https://www.intigriti.com/">Intigriti</a> : for organising a nice weekly challenges on different web application vulnerabilities such as XSS, etc.</p><p><a href="https://snyk.io/">Snyk</a> : for the awesome library of CVE’s maintained which affects the projects and client-side libraries.</p><p><a href="https://twitter.com/s1r1u5_">s1r1us</a> : for his awesome research on Prototype Pollution which helped me to figure out the Prototype Pollution Vulnerability.</p><p><a href="https://github.com/BlackFan">BlackFan</a> : for his awesome research and making a Proof of Concept on client-side prototype pollution.</p><p><a href="https://github.com/HoLyVieR">HoLyVieR</a> : for making an awesome research paper and a talk on Prototype Pollution.</p><p>— — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><p><strong><em>Note</em></strong> : I will explain different types of Cross-Site Scripting in my next blog so stay tuned for the blog my lovely beginner hacker friends and all. :)</p><p>— — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><p>Peace !!</p><p>— — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><p>Resources Used in the blog :</p><li><p><a href="https://twitter.com/intigriti/status/1670737265973182466">https://twitter.com/intigriti/</a></p></li><li><a href="https://challenge-0623.intigriti.io/challenge/index.html">XSS</a></li><li><a href="https://go.intigriti.com/submit-solution">Challenge 0623 by 0xGodson_ - Bug Bounty Program - Intigriti</a></li><li><a href="https://security.snyk.io/vuln/SNYK-JS-JQUERYDEPARAM-1255651">Snyk Vulnerability Database | Snyk</a></li><li><a href="https://www.cve.org/CVERecord?id=CVE-2021-20087">cve-website</a></li><li><a href="https://github.com/AceMetrix/jquery-deparam/blob/81428b3939c4cbe488202b5fa823ad661d64fb49/jquery-deparam.js#L22-L117">jquery-deparam/jquery-deparam.js at 81428b3939c4cbe488202b5fa823ad661d64fb49 · AceMetrix/jquery-deparam</a></li><li><a href="https://github.com/BlackFan/client-side-prototype-pollution/blob/master/pp/jquery-deparam.md">client-side-prototype-pollution/pp/jquery-deparam.md at master · BlackFan/client-side-prototype-pollution</a></li><li><a href="https://github.com/BlackFan/client-side-prototype-pollution/blob/004bf5353f6f30b720f3d68c5aca5191531f35d6/gadgets/jquery.md">client-side-prototype-pollution/gadgets/jquery.md at 004bf5353f6f30b720f3d68c5aca5191531f35d6 · BlackFan/client-side-prototype-pollution</a></li><li><p><a href="https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf">https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf</a></p></li><li><p><a href="https://blog.s1r1us.ninja/research/PP">s1r1us - Prototype Pollution</a></li></p><p>— — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=db34a45a2cc9" width="1" height="1" alt=""><hr><p><a href="https://systemweakness.com/intigritis-june-xss-challenge-writeup-db34a45a2cc9">Intigriti’s June XSS challenge: Writeup</a> was originally published in <a href="https://systemweakness.com">System Weakness</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
